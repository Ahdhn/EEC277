\section{Related Work}
%=========================Related Work====================================%
Ray tracing was first introduced in 1980 \cite{whitted1979improved} in order to introduce global illumination effects in the rendered scenes and thus more realistic effects are attainable. Since then extensive research has been done in order simulate more effects like reflection from glossy surfaces \cite{cook1984distributed, ward1988ray}, reflective lighting \cite{amanatides1984ray}, anti-aliasing \cite{shirley2008realistic,pharr2016physically, cook1984distributed}, motion blur\cite{cook1984distributed, cook1986stochastic}, depth of field \cite{shinya1994post}, etc.

In parallel, substantial amount of research has been devoted to accelerate the process of ray tracing in order to include ray tracing in interactive applications to, for example, introduce more realism in computer games. One way to accelerate the ray racing is by utilizing efficient data structure. Without such data structure, every ray would be tested against all objects in the scene making the complexity linear with the number of the primitives in the scene. 

The accelerated data structure are used in order to subdivided the scene space. There has been two ways for subdivision: spatial subdivision and object subdivision \cite{pharr2016physically}. The spatial subdivision relies on subdividing the space into sub-regions and storing primitives in each sub-region. If a ray passes through a sub-region (which is less expensive to compute), only primitives in this sub-region are checked against. One of the simplest techniques for spatial subdivision is the uniform or adaptive grid where each primitives is registered into one of the grid cells \cite{Snyder:1987:RTC:37402.37417}. Then only primitives in a certain cell are tested if a ray hits that cell. Better performance can be gained by using tree structure instead (BSP trees, kd-trees, octrees) especially for scenes with nonuniform distributions of geometry and/or with arbitrarily moving objects \cite{foley2005kd}. Object subdivision breaks down the objects in a scene into smaller constituent objects which makes it easier to cull the parts that does not hit a ray. Objects here are made of primitives. Each major object contains minor objects. Thus, we can build a tree for the major objects of minor objects \cite{Kay:1986:RTC:15886.15916}. 

Evaluating the performance of two or more different graphics APIs has been studied before in order to understand the performance limitation. Comparison between OpenGL pipline, CUDA and OpenCL has been done for various applications such as Monte Carlo simulation of quantum spin system \cite{karimi2010performance}; sorting algorithms \cite{5161005}; Sobel filter, Gaussian filter, and Median filter \cite{6419068}; volume ray casting \cite{7833400}; and others \cite{komatsu2010evaluating}. The conclusion of all these studies could be there can not be a certain API that is the best for all even though they all share similar capabilities and functionalities. 